---
title: "Discovery and Data Preparation"
author: "Michael Messmer"
output:
  html_document:
    df_print: paged
---

##Introduction

I am a tennis fanatic, so I am always looking for excuses to incorporate it into my schoolwork. Match and player stats are heavily documented and easy to find, so it seemed like perfect field to apply some statistical analysis to.

##Data

The dataset I am using is comprised of every ATP match from 2017, containing 3830 total matches.

##Source

I initially discovered the data I will be using on https://datahub.io/sports-data/atp-world-tour-tennis-data. Their datasets were obtained by scraping the official ATP (Association of Tennis Professionals) World Tour website. The scripts are open source and live on a public GitHub repository, and the ATP is the tennis equivalent to the NFL or the NBA, so it is safe to assume that the quality is quite high.

##Variables

tourney_year_id: The year that the tournament took place, followed by the tournament's numeric ID. The year will be 2017 for all of our entries, as that is the year the data was pulled from. Stored in the format <year>-<id>
tourney_order: Indicates the order that the tournaments took place in. Brisbane was the first tournament of 2017, followed by Chennai, and so on and so forth, ending with the Nitto ATP Finals as the 67th and last tournament of 2017. A value of x means that it was the xth tournament of the year.
tourney_slug: The name of the tournament in slug form (no spaces, no capitalization, no special characters).
tourney_url_suffix: The URL to be appended to "atptour.com" to find the scores for the tournament.
tourney_round_name: Indicates the round of the tournament that the match took place. "Finals", "Semi-Finals", "Round of 16", etc.
round_order: Indicates the order of the rounds. A smaller round_order indicates that the round took place later in the tournament.
match_order: Indicates the order of the matches within each round. A value of x means that it was the xth match of its round.
winner_name: The name of the player that won the match.
winner_player_id: The unique ID of the winning player. A combination of characters and digits.
winner_slug: The name of the winning player in slug form.
loser_name: The name of the player that lost the match.
loser_player_id: The unique ID of the losing player.
loser_slug: The name of the losing player in slug form.
winner_seed: The seed value of the winning player. A player with a smaller seed number is expected to beat any players with greater seed numbers.
loser_seed: The seed value of the losing player.
match_score_tiebreaks: The final score of the match. The scoring system in tennis is somewhat complicated, and seeing this data is not currently relevant to our analysis, we will forgo a more detailed explanation.
winner_sets_won: The amount of sets won by the player that won the match.
loser_sets_won: The amount of sets won by the player that lost the match.
winner_games_won: The amount of games won by the player that won the match.
loser_games_won: The amount of games won by the player that lost the match.
winner_tiebreaks_won: The amount of tiebreaks won by the player that won the match.
loser_tiebreaks_won: The amount of tiebreaks won by the player that lost the match.
match_id: The unique ID for the match. Stored in the format <year>-<tourney_id>-<winner_player_id>-<loser_player_id>
match_stats_ur_suffix: The URL to be appended to "atptour.com" to find detailed stats for the match.

##Tidying the Data

First, we need to install the tidyverse library so we can import and manipulate our data.

```{r}
suppressMessages(install.packages("tidyverse", repos = "http://cran.us.r-project.org"))
suppressMessages(library("tidyverse"))

data <- read_csv("https://raw.githubusercontent.com/datasets/atp-world-tour-tennis-data/master/csv/2_match_scores/match_scores_2017_UNINDEXED.csv")
```

Let's take a look at the column names and make sure they're all suitable.

```{r}
colnames(data)
```

These names look quite good. They have consistent syntax, they're all unambiguous, and they all accurately describe what they represent. Renaiming does not seem necessary.

That being said, much of this data is irrelevant for our studies. For example, tourney_order has nothing to do with seeding, and we probably don't need both player names and player ids. Let's load some libraries for tidying the data.

```{r}
suppressMessages(library("dplyr"))
suppressMessages(library("tidyr"))
```

Each entry in the data neatly describes a single match, which is great. But because there is a lot of data that we don't care about, we will create a match table that contains only the relevant columns.

```{r}
match <- tibble("tourney_slug"=data$tourney_slug, "tourney_round_name"=data$tourney_round_name, "winner_name"=data$winner_name, "loser_name"=data$loser_name, "winner_seed"=data$winner_seed, "loser_seed"=data$loser_seed)
head(match)
```

That looks much better. One thing to notice is that our seeds have been encoded as characters rather than as integers. Looking at the loser_seed of the last 2 rows gives us some insight as to why, as well as showing a few other issues. Players that aren't seeded are given a value of NA, which can't be directly compared with our numerical seeds. There is also another seed that isn't a numeric value, WC. Let's take a closer look at our seed values.

```{r}
levels(as.factor(match$winner_seed))
levels(as.factor(match$loser_seed))
```

We can see that some seeds are indeed character values, such as WC and AL. WC is what's known as a wild card in tennis. The distinction between a seeded player with or without a wild card is not relevant to our analysis, so we will treat them as equivalent.

```{r}
match$winner_seed[match$winner_seed == "1 AL"] <- "1"
match$winner_seed[match$winner_seed == "1 WC"] <- "1"
match$winner_seed[match$winner_seed == "14 WC"] <- "14"
match$winner_seed[match$winner_seed == "2 WC"] <- "2"
match$winner_seed[match$winner_seed == "3 WC"] <- "3"
match$winner_seed[match$winner_seed == "4 WC"] <- "4"
match$winner_seed[match$winner_seed == "5 WC"] <- "5"
match$winner_seed[match$winner_seed == "6 WC"] <- "6"
match$winner_seed[match$winner_seed == "7 WC"] <- "7"
match$winner_seed[match$winner_seed == "8 WC"] <- "8"
match$loser_seed[match$loser_seed == "1 WC"] <- "1"
match$loser_seed[match$loser_seed == "14 WC"] <- "14"
match$loser_seed[match$loser_seed == "2 WC"] <- "2"
match$loser_seed[match$loser_seed == "3 WC"] <- "3"
match$loser_seed[match$loser_seed == "4 WC"] <- "4"
match$loser_seed[match$loser_seed == "5 WC"] <- "5"
match$loser_seed[match$loser_seed == "6 WC"] <- "6"
match$loser_seed[match$loser_seed == "7 WC"] <- "7"
match$loser_seed[match$loser_seed == "8 WC"] <- "8"
```

The distinction rest of the non-numeric seeds are also not relevant to our analysis, and can all be treated as equivalent and less than any numeric seed. For now, we'll give them an arbitrary numeric value that is greater than any numeric seed. It is important to note that the lower the numeric value is, the higher the seed is. For example, a 3 seeded player is expected to beat a 7 seeded player. So although the numeric value we are assigning is greater than the official seeds, this actually means that they will be treated as a lower seed, which means they would be expected to lose to an officially seeded player.

```{r}
match$winner_seed[match$winner_seed == "AL"] <- "50"
match$winner_seed[match$winner_seed == "LL"] <- "50"
match$winner_seed[match$winner_seed == "PR"] <- "50"
match$winner_seed[match$winner_seed == "Q"] <- "50"
match$winner_seed[match$winner_seed == "S"] <- "50"
match$winner_seed[match$winner_seed == "WC"] <- "50"
match$loser_seed[match$loser_seed == "AL"] <- "50"
match$loser_seed[match$loser_seed == "Alt"] <- "50"
match$loser_seed[match$loser_seed == "LL"] <- "50"
match$loser_seed[match$loser_seed == "PR"] <- "50"
match$loser_seed[match$loser_seed == "Q"] <- "50"
match$loser_seed[match$loser_seed == "S"] <- "50"
match$loser_seed[match$loser_seed == "WC"] <- "50"

levels(as.factor(match$winner_seed))
levels(as.factor(match$loser_seed))
```

This looks much better, all of our seeds are numeric now. However, they are still encoded as characters, which means they cannot be properly compared in some cases.

```{r}
18 < 2
"18" < "2"
```

In order to ensure that we can properly compare seeds, we must make sure they are encoded as numbers rather than characters.

```{r}
match$winner_seed <- as.numeric(match$winner_seed)
match$loser_seed <- as.numeric(match$loser_seed)

typeof(match$winner_seed)
typeof(match$loser_seed)
```

Next we should address the NA problem. We have no way of comparing nonseeded players directly to each other, so for the sake of this analysis, we will assign them the same number that our non-numeric seeds were given, to indicate that they are expected to lose to any seeded player.

```{r}
match$winner_seed[is.na(match$winner_seed)] <- 50
match$loser_seed[is.na(match$loser_seed)] <- 50
```

In fact, since we can't obtain any useful insight from matches between two unseeded players, let's just remove these matches from our table entirely.

```{r}
match <- filter(match, (winner_seed != 50 | loser_seed != 50))
```

Now we are just left with matches between 2 players of different seed levels. Let's make some visualizations to see what the data tells us.

##Visualization

```{r}

```
